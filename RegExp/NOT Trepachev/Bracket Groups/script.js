/*
Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».

У такого выделения есть два эффекта:

Позволяет поместить часть совпадения в отдельный массив.
Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки,
а не к одному символу.

Метод str.match(regexp), если у регулярного выражения regexp нет флага g, 
ищет первое совпадение и возвращает его в виде массива:

На позиции 0 будет всё совпадение целиком.
На позиции 1 – содержимое первой скобочной группы.
На позиции 2 – содержимое второй скобочной группы.
…и так далее…


Метод str.match возвращает скобочные группы только без флага g.
Метод str.matchAll возвращает скобочные группы всегда.

Содержимое скобочной группы можно также использовать при замене 
str.replace(regexp, replacement): по номеру $n или по имени $<имя>.

Можно исключить скобочную группу из запоминания, добавив в её начало ?:. 
Это используется, если необходимо применить квантификатор ко всей группе, 
но не запоминать их содержимое в отдельном элементе массива-результата. 
Также мы не можем ссылаться на такие скобки в строке замены.
*/

/*
Пример: gogogo

Без скобок шаблон go+ означает символ g и идущий после него символ o, 
который повторяется один или более раз. Например, goooo или gooooooooo.

Скобки группируют символы вместе. 
Так что (go)+ означает go, gogo, gogogo и т.п.
*/

console.log( `Gogogo now`.match(/(go)+/ig)); // ['Gogogo']


/*
Пример: домен

Например:
mail.com
users.mail.com
smith.users.mail.com

Как видно, домен состоит из повторяющихся слов, 
причём после каждого, кроме последнего, стоит точка.

На языке регулярных выражений (\w+\.)+\w+.

Поиск работает, но такому шаблону не соответствует домен с дефисом, 
например, my-site.com, так как дефис не входит в класс \w.
Можно исправить это, заменим \w на [\w-]
*/
let regexp = /([\w-]+\.)+\w/gi;
console.log( `site.com my.site.com`.match(regexp) ); // ['site.c', 'my.site.c']


/*
Пример: email

Предыдущий пример можно расширить, создав регулярное выражение для поиска email.

Формат email: имя@домен. В качестве имени может быть любое слово, 
разрешены дефисы и точки. 
На языке регулярных выражений это [-.\w]+.
*/
let regex = /([\w-.]+@([\w-]+\.)+[\w-]+)/ig;
console.log( `my@mail.com @ his@site.com.uk`.match(regex) ); // ['my@mail.com', 'his@site.com.uk']


/*
Содержимое скобок в match

Например, мы хотим найти HTML теги <.*?> и обработать их. 
Было бы удобно иметь содержимое тега (то, что внутри уголков) в отдельной переменной.

Давайте заключим внутреннее содержимое в круглые скобки: <(.*?)>.

Теперь получим как тег целиком <h1>, так и его содержимое h1 в виде массива:
*/
let str = '<h1>Hello, world!</h1>';
let tag = str.match(/<(.*?)>/);

console.log( tag[0] ); // <h1>
console.log( tag[1] ); // h1


/*
Вложенные группы

Скобки могут быть и вложенными.
*/
let str2 = '<span class="my">';

let regexp2 = /<(([a-z]+)\s*([^>]*))>/;

let result = str2.match(regexp2);
console.log(result[0]); // <span class="my">
console.log(result[1]); // span class="my"
console.log(result[2]); // span
console.log(result[3]); // class="my"


/*
matchAll

При поиске всех совпадений (флаг g) 
метод match не возвращает скобочные группы.

Результат – массив совпадений, но без деталей о каждом. 
Но на практике скобочные группы тоже часто нужны.

Для того, чтобы их получать, мы можем использовать метод str.matchAll(regexp).

Он был добавлен в язык JavaScript гораздо позже чем str.match, 
как его «новая и улучшенная» версия.

Он, как и str.match(regexp), ищет совпадения, 
но у него есть три отличия:

Он возвращает не массив, а перебираемый объект.
При поиске с флагом g, он возвращает каждое совпадение 
в виде массива со скобочными группами.
Если совпадений нет, он возвращает не null, 
а просто пустой перебираемый объект.
*/

let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

// results - не массив, а перебираемый объект
console.log(results); // [object RegExp String Iterator]

console.log(results[0]); // undefined (*)

results = Array.from(results); // превращаем в массив

console.log(results[0]); // <h1>,h1 (первый тег)
console.log(results[1]); // <h2>,h2 (второй тег)



/*
Именованные группы

Запоминать группы по номерам не очень удобно. 
Для простых шаблонов это допустимо, 
но в сложных регулярных выражениях считать скобки затруднительно. 
Гораздо лучше – давать скобкам имена.

Это делается добавлением ?<name> непосредственно после открытия скобки.
*/

let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
let str5 = "2019-04-30";

let groups = str5.match(dateRegexp).groups;

// console.log(groups.year); // 2019
// console.log(groups.month); // 04
// console.log(groups.day); // 30

//Также нам понадобится matchAll, чтобы получить скобочные группы:
let dateRegexp2 = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str6 = "2019-10-30 2020-01-01";

let results6 = str6.matchAll(dateRegexp2);

for(let result of results6) {
  let {year, month, day} = result.groups;

  console.log(`${day}.${month}.${year}`);
  // первый вывод: 30.10.2019
  // второй: 01.01.2020
}



/*
Скобочные группы при замене

Метод str.replace(regexp, replacement), осуществляющий замену совпадений с regexp в строке str, 
позволяет использовать в строке замены содержимое скобок. 
Это делается при помощи обозначений вида $n, где n – номер скобочной группы.
*/
let str7 = "John Bull";
let regexp7 = /(\w+) (\w+)/;

console.log( str7.replace(regexp7, '$2, $1') ); // Bull, John


//Для именованных скобок ссылка будет выглядеть как $<имя>.
//Например, заменим даты в формате «год-месяц-день» на «день.месяц.год»:

let regexp8 = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str8 = "2019-10-30, 2020-01-01";

console.log( str8.replace(regexp8, '$<day>.$<month>.$<year>') );
// 30.10.2019, 01.01.2020



/*
Исключение из запоминания через ?:

Бывает так, что скобки нужны, чтобы квантификатор правильно применился, 
но мы не хотим, чтобы их содержимое было выделено в результате.

Скобочную группу можно исключить из запоминаемых и нумеруемых, 
добавив в её начало ?:.

Например, если мы хотим найти (go)+, 
но не хотим иметь в массиве-результате отдельным элементом содержимое скобок (go), 
то можем написать (?:go)+.

В примере ниже мы получим только имя John как отдельный элемент совпадения:
*/

let str10 = "Gogogo John!";

// ?: исключает go из запоминания
let regexp10 = /(?:go)+ (\w+)/i;

let result10 = str10.match(regexp10);

console.log( result10[0] ); // Gogogo John (полное совпадение)
console.log( result10[1] ); // John
console.log( result10.length ); // 2 (больше в массиве элементов нет)


