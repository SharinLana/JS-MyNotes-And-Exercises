/* 
Вот полный перечень этих символов: 
[ ] \ ^ $ . | ? * + ( ) 

1. Для поиска специальных символов [ ] \ ^ $ . | ? * + ( ), 
нам нужно добавить перед ними \ («экранировать их»).

2. Нам также нужно экранировать /, если мы используем /.../ 
(но не new RegExp).

3. При передаче строки в new RegExp 
нужно удваивать обратную косую черту: \\ 
для экранирования специальных символов, 
потому что строковые кавычки «съедят» одну черту.

*/

/*
Экранирование символов
Допустим, мы хотим найти буквально точку. 
Не «любой символ», а именно точку.
Чтобы использовать специальный символ как обычный, 
добавьте к нему обратную косую черту: \..

Это называется «экранирование символа».
*/

console.log(`Chapter 5.1`.match(/\d\.\d/g)); // ['5.1']
console.log(`Chapter 5.1`.match(/\./g)); // ['.']
console.log(`Chapter 51`.match(/\d\.\d/g)); // null


/*
Круглые скобки () также являются специальными символами, 
поэтому, если нам нужно использовать именно их, 
нужно указать 
\(
\)
*/
console.log(`Phone Number +1 (347) 542 0931`.match(/\(\d\d\d\)/g)); // ['(347)']


/* 
Если мы ищем обратную косую черту \,
мы должны удвоить её.
*/
console.log(`Producer \\ Reporter`.match(/\\/g)); // ['\\']


/*
Косая черта
*/
console.log(`/`.match(/\//)); // ['/', index: 0, input: '/', groups: undefined]

//С другой стороны, если мы не используем короткую запись /.../, 
//а создаём регулярное выражение, используя new RegExp, 
//тогда нам не нужно экранировать косую черту:
console.log( "/".match(new RegExp("/")) ); // ['/', index: 0, input: '/', groups: undefined]


/*
new RegExp
Если мы создаём регулярное выражение с помощью new RegExp, 
то нам нужно удвоить обратную косую черту, 
потому что строковые кавычки превращают \\ в \:
*/
let regStr = '\\d\\.\\d';
console.log(regStr); // \d\.\d
let regexp = new RegExp(regStr);
console.log("Chapter 5.1".match(regexp)); // ['5.1', index: 8, input: 'Chapter 5.1', groups: undefined]